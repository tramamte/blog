+++
title = "상수에 대한 오해"
description = "C/C++, Java 개발자들의 상수에 대한 오해 풀기"
topics = ["go"]
tags = ["fun-go"]
slug = "constant-misunderstanding"
date = "2018-07-17T12:47:49+09:00"
imports = ["math", "zimg", "flowchart", "sequence", "mermaid"]
draft = true
+++

상수에 대해서만 벌써 네 번째 글이다. 

- [상수]({{< ref "20180607-18-20" >}})
- [별 것 없을 것 같은 상수의 별 것]({{< ref "20180607-18-32" >}})
- [정수형 상수의 내부 처리]({{< ref "20180703-22-35" >}})

그만큼 Go의 상수는 C/C++이나 Java를 사용했던 개발자가 오해할만한 요소를 많이 포함하고 있다.

우선 C/C++에서 상수를 만드는 키워드인 `const`와 `final`에 대해 간략히 정리해보자.

---

C/C++ `const`의 역할

- 변수의 읽기전용 설정 = 상수화
- (C++) 멤버 함수의 멤버 변수 변경 금지

Java `final`의 역할

- 변수의 읽기전용 설정 = 상수화
- 메서드의 오버라이딩 금지
- 클래스의 상속 금지

---

다른 것들은 같은 키워드를 사용할 뿐 **상수**라 부르지 않고, 사실 Go에는 없는 기능들이니 첫 번째 역할에 대해서만 살펴보자.

Go와의 확실한 구분을 위해 일부러 **변수의 읽기전용화**라 표현했다. C/C++, Java에서 상수는 변수를 만드는 것과 동일하게 이름과 타입을 정한 후 최초 한 번 값을 설정하면 읽기전용이 돼 변경이 불가능하다.

```c
const int i = 10;
```

```java
final int i = 10;
```

변수를 읽기전용화한 것이기 때문에 다음과 같은 문법은 당연하며 자연스럽다.

```c
// c
struct MyStruct
{
	int i;
};

const struct MyStruct my = {0};
```

> 변수를 만들 수 있으면 상수도 만들 수 있다.

이 당연했던 사실이 Go에서는 오해의 요인이 된다.

# 변수는 변수, 상수는 상수

