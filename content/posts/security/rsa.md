+++
title = "중학교 수학으로 이해하는 RSA"
description = "RSA 암호화의 이해"
topics = ["security"]
tags = ["pki", "rsa", "cryptography"]
slug = "rsa"
date = "2018-07-17T16:20:45+09:00"
imports = ["math"]
draft = true
+++

PKI의 근간이 되는 RSA 암호화에 대해 중학교 수준의 수학만 사용해 알아보자. 이해를 위해 필요한 기반 지식들 역시 최대한 간단히, 중학교 수준에서만 다룬다.

# 기반 지식

오일러 파이[^1] 함수 (Euler's phi function 또는 Euler's totient function), 페르마 소정리 (Fermat's little theorem)와 이의 일반화 형태인 오일러 정리 (Euler's theorem)에 대해 딱 RSA를 이해하는데 필요한 수준만 간략히 알아보자. 

[^1]: 원주율을 표시할 때 사용하는 \\(\pi\\)와의 구분을 위해 ’피’라 읽기도 하는데 그냥 ’파이’로 표기한다.

## 오일러 파이 함수 (Euler's phi function)

오일러 파이 함수는 1부터 \\(n\\)까지의 양의 정수 중 \\(n\\)과 서로소인 것의 개수를 나타내는 함수이다. \\(\varphi(n)\\)이나 \\(\phi(n)\\)으로 표기한다.

예를 들면,

- 3을 기준으로 1부터 3까지의 양의 정수 1, 2, 3 중 3과 서로소인 수는 1, 2이므로 \\(\varphi(3) = 2\\)
- 4를 기준으로 1부터 4까지의 양의 정수 1, 2, 3, 4 중 4와 서로소인 수는 1, 3이므로 \\(\varphi(4) = 2\\)
- 5를 기준으로 1부터 5까지의 양의 정수 1, 2, 3, 4, 5 중 5와 서로소인 수는 1, 2, 3, 4이므로 \\(\varphi(5) = 4\\)
- 6을 기준으로 1부터 6까지의 양의 정수 1, 2, 3, 4, 5, 6 중 6과 서로소인 수는 1, 5이므로 \\(\varphi(6) = 2\\)
- 7을 기준으로 1부터 7까지의 양의 정수 1, 2, 3, 4, 5, 6, 7 중 7과 서로소인 수는 1, 2, 3, 4, 5, 6이므로 \\(\varphi(7) = 6\\)
- 8을 기준으로 1부터 8까지의 양의 정수 1, 2, 3, 4, 5, 6, 7, 8 중 8과 서로소인 수는 1, 3, 5, 7이므로 \\(\varphi(8) = 4\\)

이 된다.

특징이 보이는가? 보이지 않는다면 소수의 정의를 한 번 생각해 보자. 소수는 1과 자기 자신 외에는 나누어 떨어지지 않는 수이다. 그런데 파이 함수는 1은 개수에 포함한다. 따라서 여기서 파이 함수의 첫 번째 특징을 알 수 있다.

{{% box "#ffeeff" %}}

\\(n\\)이 소수인 경우,

$$\varphi(n) = n - 1$$

{{% /box %}}

6의 경우를 다시 보자. 6을 소인수분해하면 1, 6 외에도 2, 3의 인수---또는 약수---를 갖는다. 따라서 \\(\varphi(6)\\)은 1부터 6까지 전체 6개의 숫자 중 자기 자신(6) 한 개, 2의 배수(2, 4) 두 개, 3의 배수(3) 한 개를 뺀 \\(6 - (1 + 2 + 1) = 2\\)가 된다.

이를 기반으로 사고를 확장해 보면, \\(m\\)과 \\(n\\)이 서로 다른 소수인 경우---당연히 서로소가 된다--- \\(m\\)과 \\(n\\)을 곱한 수 \\(mn\\)의 파이 함수 값 \\(\varphi(mn)\\)은 전체 \\(mn\\)개의 숫자 중 \\(1m\\), \\(2m\\), ..., \\(nm\\) 등 \\(m\\)의 배수 \\(n\\)개를 제외하고, \\(1n\\), \\(2n\\), ..., \\(mn\\) 등 \\(n\\)의 배수 \\(m\\)개를 제외한 뒤 자기 자신(\\(mn\\))은 두 번 제외됐으므로 한 번 더해주는 방식으로 구할 수 있다. 여기서 두 번째 특징이 나온다.

{{% box "#ffeeff" %}}

\\(m\\), \\(n\\)이 서로 다른 소수인 경우 두 수의 곱에 대한 파이 함수 값 \\(\varphi(mn)\\)은 다음과 같이 구할 수 있다.

$$ \varphi(mn) = mn - n - m + 1 = (m - 1)(n - 1) $$

따라서 아래 등식이 성립한다.

$$ \varphi(mn) = \varphi(m)\varphi(n) $$

{{% /box %}}

## 페르마 소정리 (Fermat's littel theorem)

페르마의 소정리는 어떤 수가 소수일 필요조건에 대한 정리이다. 따라서 모든 소수는 정리를 만족하지만, 정리를 만족해도 소수가 아닐 수 있다.

페르마의 소정리는 보통 [합동 산술 (modular arithmetic)](https://ko.wikipedia.org/wiki/%ED%95%A9%EB%8F%99_%EC%82%B0%EC%88%A0)에서 정의한 기호로 표기하는데 이는 중학교 범위를 벗어나니 최대한 쉬운 용어로 바꿔보자. 단, 개발자에게 친숙한 나머지 연산에 한해서는 \\(mod\\)로 표기하겠다.

- https://ko.wikipedia.org/wiki/%ED%8E%98%EB%A5%B4%EB%A7%88%EC%9D%98_%EC%86%8C%EC%A0%95%EB%A6%AC

## 오일러 정리 (Euler's theorem)



# 키 생성 절차

# 암호화 및 복호화 예제 