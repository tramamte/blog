+++
title = "중학교 수학으로 이해하는 RSA"
description = "RSA 암호화의 이해"
topics = ["security"]
tags = ["pki", "rsa", "cryptography"]
slug = "rsa"
date = "2018-07-17T16:20:45+09:00"
imports = ["math"]
draft = true
+++

PKI의 근간이 되는 RSA 암호화에 대해 중학교 수준의 수학만 사용해 알아보자. 이해를 위해 필요한 기반 지식들 역시 최대한 간단히, 중학교 수준에서만 다룬다.

# 기반 지식

오일러 파이[^1] 함수 (Euler's phi function 또는 Euler's totient function), 페르마 소정리 (Fermat's little theorem)와 이의 일반화 형태인 오일러 정리 (Euler's theorem)에 대해 딱 RSA를 이해하는데 필요한 수준만 간략히 알아보자. 

[^1]: 원주율을 표시할 때 사용하는 \\(\pi\\)와의 구분을 위해 ’피’라 읽기도 하는데 여기서는 ’파이’로 표기한다.

## 오일러 파이 함수 (Euler's phi function)

오일러 파이 함수는 1부터 \\(n\\)까지의 양의 정수 중 \\(n\\)과 서로소인 것의 개수를 나타내는 함수이다. \\(\varphi(n)\\)이나 \\(\phi(n)\\)으로 표기한다.

예를 들면,

- 3을 기준으로 1부터 3까지의 양의 정수 1, 2, 3 중 3과 서로소인 수는 1, 2이므로 \\(\varphi(3) = 2\\)
- 4를 기준으로 1부터 4까지의 양의 정수 1, 2, 3, 4 중 4와 서로소인 수는 1, 3이므로 \\(\varphi(4) = 2\\)
- 5를 기준으로 1부터 5까지의 양의 정수 1, 2, 3, 4, 5 중 5와 서로소인 수는 1, 2, 3, 4이므로 \\(\varphi(5) = 4\\)
- 6을 기준으로 1부터 6까지의 양의 정수 1, 2, 3, 4, 5, 6 중 6과 서로소인 수는 1, 5이므로 \\(\varphi(6) = 2\\)
- 7을 기준으로 1부터 7까지의 양의 정수 1, 2, 3, 4, 5, 6, 7 중 7과 서로소인 수는 1, 2, 3, 4, 5, 6이므로 \\(\varphi(7) = 6\\)
- 8을 기준으로 1부터 8까지의 양의 정수 1, 2, 3, 4, 5, 6, 7, 8 중 8과 서로소인 수는 1, 3, 5, 7이므로 \\(\varphi(8) = 4\\)

이 된다.

특징이 보이는가? 보이지 않는다면 소수의 정의를 한 번 생각해 보자. 소수는 1과 자기 자신 외에는 나누어 떨어지지 않는 수이다. 그런데 파이 함수는 1은 개수에 포함한다. 따라서 여기서 파이 함수의 첫 번째 특징을 알 수 있다.

{{% box "#ffeeff" %}}

\\(n\\)이 소수인 경우,

$$\varphi(n) = n - 1$$

{{% /box %}}

6의 경우를 다시 보자. 6은 1, 6 외에도 2, 3의 약수---또는 인수---를 갖는다. 따라서 \\(\varphi(6)\\)은 1부터 6까지 전체 6개의 숫자 중 자기 자신(6) 한 개, 2의 배수(2, 4) 두 개, 3의 배수(3) 한 개를 뺀 \\(6 - (1 + 2 + 1) = 2\\)가 된다.

이를 기반으로 사고를 확장해 보면, \\(m\\)과 \\(n\\)이 서로 다른 소수인 경우---당연히 서로소가 된다--- \\(m\\)과 \\(n\\)을 곱한 수 \\(mn\\)의 파이 함수 값 \\(\varphi(mn)\\)은 전체 \\(mn\\)개의 숫자 중 \\(1m\\), \\(2m\\), ..., \\(nm\\) 등 \\(m\\)의 배수 \\(n\\)개를 제외하고, \\(1n\\), \\(2n\\), ..., \\(mn\\) 등 \\(n\\)의 배수 \\(m\\)개를 제외한 뒤 자기 자신(\\(mn\\))은 두 번 제외됐으므로 한 번 더해주는 방식으로 구할 수 있다. 여기서 두 번째 특징이 나온다.

{{% box "#ffeeff" %}}

\\(m\\), \\(n\\)이 서로 다른 소수인 경우 두 수의 곱에 대한 파이 함수 값 \\(\varphi(mn)\\)은 다음과 같이 구할 수 있다.

$$ \begin{matrix} \varphi(mn) &=& mn - n - m + 1\\\ &=& (m - 1)(n - 1) \end{matrix} $$

따라서 아래 등식이 성립한다.

$$ \varphi(mn) = \varphi(m)\varphi(n) $$

{{% /box %}}

## 페르마 소정리 (Fermat's littel theorem)

페르마의 소정리는 어떤 수가 소수일 필요조건에 대한 정리이다. 따라서 모든 소수는 정리를 만족하지만, 정리를 만족해도 소수가 아닐 수 있다.

페르마의 소정리는 보통 [합동 산술 (modular arithmetic)](https://ko.wikipedia.org/wiki/%ED%95%A9%EB%8F%99_%EC%82%B0%EC%88%A0)에서 정의한 기호로 표기하는데 이는 중학교 범위를 벗어나니 최대한 쉬운 용어로 바꿔보자. 단, 개발자에게 친숙한 나머지 연산에 한해서는 \\(\bmod\\)로 표기하겠다.

{{% box "#ffeeff" %}}

\\(p\\)가 소수이고 \\(a\\)가 \\(p\\)로 나누어 떨어지지 않는 경우,

$$ a^p\,\bmod\,p = a\,\bmod\,p $$

\\(a\\)가 0인 경우는 당연히 성립하며, \\(a \neq 0\\)인 경우 다음 식도 성립한다.

$$ a^{(p-1)}\,\bmod\,p = 1\,\bmod\,p $$

{{% /box %}}

우선 첫 번째 공식이 성립한다는 가정하에 두 번째 공식이 성립함을 확인해보자.

\\(a^p\\)와 \\(a\\)를 각각 \\(p\\)로 나눈 나머지가 같으므로 \\(r\\)을 나머지, \\(m\\), \\(n\\)을 임의의 정수라고 했을 때 \\(a^p\\), \\(a\\)는 다음과 같이 쓸 수 있다.

$$ a^p = pm +k $$

$$ a = pn +k $$

\\(a^p\\)에서 \\(a\\)를 빼면,

$$ \begin{matrix} a^p - a &=& (pm + k) - (pn - k) \\\ &=& p(m - n) \end{matrix} $$

이 되기 때문에 \\(p\\)로 나누어 떨어진다.

$$ \left( a^p - a \right)\,\bmod\,p = 0 $$

즉, \\(a^p - a\\)를 \\(p\\)로 나누면 임의의 정수 \\(l\\)이 된다.

$$ {{a^p - a} \over p} = {{ a \left( a^{p-1} - 1 \right) } \over p} = l $$

그런데 조건에서 \\(a\\)는 \\(p\\)로 나누어 떨어지지 않고 \\(p\\)는 소수이므로, 위 식을 만족하려면 \\( a^{p-1} - 1 \\)이 \\(p\\)로 나누어 떨어져야 한다. 즉, \\( a^{p-1} \\)을 \\(p\\)로 나누면 나머지 1이 남는다.

위에서 언급한 것처럼 합동 산술은 중학교 수준을 벗어나지만, 대부분의 관련 자료에서 합동 산술의 표기법을 사용하니 관련된 두 가지 표기법만 짚고 넘어가자.

- \\(b\\)가 \\(a\\)로 나누어 떨어진다. 또는, \\(b\\)가 \\(a\\)로 나누어 떨어지지 않는다.
$$ a \mid b\ ,\  a \nmid b $$
- \\(a\\)를 \\(n\\)으로 나눈 나머지와 \\(b\\)를 \\(n\\)으로 나눈 나머지가 같다.
$$ a \equiv b \pmod{n} $$

특히 두 번째 항목을 *\\(a\\)와 \\(b\\)는 법 \\(n\\)에 대해 합동이다. (\\(a\\) is congruent to \\(b\\) modulo \\(m\\))* 라고 표현한다.

페르마 소정리는 아래 오일러 정리의 특수한 경우에 해당하니 증명은 오일러 정리의 증명으로 대신하자.

## 오일러 정리 (Euler's theorem)

오일러 정리는 페르마 소정리에 대한 일반 형태로 페르마 소정리에서의 소수 \\(p\\)를 일반 정수 \\(n\\)으로 확장한 형태이다.

{{% box "#ffeeff" %}}

임의의 0보다 큰 정수 \\(a\\)와 \\(n\\)이 서로소일 때,

$$ a^{\varphi(n)}\,\bmod\,n = 1\,\bmod\,n $$

{{% /box %}}

\\(n\\)이 소수인 경우 오일러 파이 함수의 첫 번째 특징에 의해  페르마 소정리의 두 번째 식과 같아진다.

오일러 정리를 증명해보자.

1부터 \\(n\\)까지의 정수 중 \\(n\\)과 서로소인 \\(\varphi(n)\\)개의 수들을 \\( r _ 1, \cdots, r _ {\varphi(n)} \\)라고 하면, 각각에 \\( a \\)를 곱한 \\( ar _ 1, \cdots, ar _ {\varphi(n)} \\) 역시 \\( n \\)과 서로소인 수들의 곱이므로 \\(n \\)과 서로소이다. 또, 이 수들을 \\( n \\)으로 나눈 나머지들을 모두 서로 다르다.

왜냐하면,

만약 나머지가 같은 \\( ar _ i,\ ar _ j\ (0 < r _ i < r _ j < n) \\)가 있다면, \\( ar _ j - ar _ i = a( r _ j - r _ i)\\)는 \\(n\\)으로 나누어 떨어진다. 그런데 \\(a\\)는 \\(n\\)과 서로소이므로 \\(r _ j - r _ i \\)가 \\(n\\)으로 나누어 떨어져야 한다. 하지만 \\( n > r _ j > r _ i \\)이므로 \\( r _ j - r _ i \\)가 \\(n\\)으로 나누어 떨어질 수 없다. 따라서 가정이 거짓이고, 이에 따라 나머지는 모두 다르다.

각 \\(r _ i\ (1 \le i \le \varphi(n))\\)에 \\(a\\)를 곱한 수를 살펴보자. 이 수는 다음과 같이 쓸 수 있다.

$$ ar _ i = nq _ i + m _ i\ (1 \le i \le \varphi(n)) $$

\\(n\\)으로 나눴을 때 몫이 \\(q_i\\), 나머지가 \\(m_i\\)라는 의미이다. 위에서 이미 나머지들은 모두 서로 다르다는 것을 밝혔으니 나머지의 경우의 수 역시 \\(\varphi(n)\\)가지이다. 그리고 \\(m _ i\\)들은 모두 \\(n\\)과 서로소이다.

왜냐하면,

만약 \\(m_i\\)와 \\(n\\)이 서로소가 아니고 1이 아닌 공약수 \\(d\\)를 갖는다면, \\(m_i = dl_i\\), \\(n = dk\\)라 할 수 있고, \\(ar_i\\)는 다음과 같이 쓸 수 있다.

$$ \begin{matrix} ar_i &=& nq_i + m_i \\\ &=& dkq_i + dl_i \\\ &=& d(kq_i + l_i) \end{matrix} $$

이 경우 \\(ar_i\\)와 \\(n\\)은 1이 아닌 공약수 \\(d\\)를 갖게 되기 때문에 서로소가 아니게 된다. 따라서 \\(m_i\\)와 \\(n\\)은 서로소이다.

정리하면, \\(m_i\\)는 \\(n\\)으로 나눈 나머지이므로 \\(n\\)보다는 작고, \\(n\\)과 서로소인 \\(\varphi(n)\\)개의 수이다. 즉, \\(r_i\\)와 순서만 다른 같은 수들의 집합이다.

이제 \\(ar_i\\)들을 모두 곱하면,

$$ \begin{matrix} ar _ 1 \times \cdots \times ar _ {\varphi(n)} \\\ = (nq _ 1 + m _ 1) \times \cdots \times (nq _ {\varphi(n)} + m _ {\varphi(n)}) \end{matrix} $$

이 되는데, 이 식을 전개하면 모든 항에 \\(n\\)이 한 개 이상 포함되고, 마지막 항 \\(m _ 1 \times \cdots \times m _ {\varphi(n)}\\)만 \\(n\\)을 포함하지 않는다. 위에서 \\(m_i\\)는 순서만 바뀐 \\(r_i\\)와 같은 수들의 집합이라는 것을 밝혔으니 \\(n\\)이 포함되지 않은 마지막 항은 \\(r _ 1 \times \cdots \times r _ {\varphi(n)}\\)과 같다. 따라서 \\(ar_i\\)들을 모두 곱한 수를 \\(n\\)으로 나눈 나머지는 \\(r_i\\)들을 모두 곱한 수를 \\(n\\)으로 나눈 나머지와 같다.

$$ \begin{matrix} ar _ 1 \times \cdots \times ar _ {\varphi(n)} \\\ = b _ 1 n ^ {\varphi(n)} + b _ 2 n ^ {\varphi(n) - 1} + \cdots + (m _ 1 \times \cdots \times m _ {\varphi(n)}) \\\ = b _ 1 n ^ {\varphi(n)} + b _ 2 n ^ {\varphi(n) - 1} + \cdots + (r _ 1 \times \cdots \times r _ {\varphi(n)}) \end{matrix} $$

$$ \begin{matrix} \therefore (ar _ 1 \times \cdots \times ar _ {\varphi(n)})\,\bmod\,n \\\ = (r _ 1 \times \cdots \times r _ {\varphi(n)})\,\bmod\,n \end{matrix} $$

두 곱한 수를 \\(n\\)으로 나눴을 때 나머지가 같으므로 \\(ar_i\\)들의 곱에서 \\(r_i\\)들의 곱을 뺀 수는 \\(n\\)으로 나누어 떨어진다. 즉,

$$ (ar _ 1 \times \cdots \times ar _ {\varphi(n)} - r _ 1 \times \cdots \times r _ {\varphi(n)}) \,\bmod\,n = 0 $$

$$ (a ^ {\varphi(n)} - 1)(r _ 1 \times \cdots \times r _ {\varphi(n)})\,\bmod\,n = 0 $$

이 중 \\(r _ 1 \times \cdots \times r _ {\varphi(n)}\\)는 \\(n\\)과 서로소인 수들의 곱이므로 역시 \\(n\\)과 서로소이다. 따라서 위 식을 만족하려면 \\(a ^ {\varphi(n)} - 1\\)이 \\(n\\)으로 나누어 떨어져야 한다. 즉,

$$ (a ^ {\varphi(n)} - 1)\,\bmod\,n = 0 $$

$$ \therefore a ^ {\varphi(n)}\,\bmod\,n = 1 $$

지금까지는 \\(n\\)이 1보다 큰 경우만 가정했는데, 1인 경우도 고려하면 다음과 같다.

$$ a ^ {\varphi(n)}\,\bmod\,n = 1\,\bmod\,n $$

# 키 생성 절차

# 암호화 및 복호화